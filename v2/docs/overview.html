#Overview

Flour is a small framework for building rich front ends with simple APIs. With a total file size at under 10kb and no dependencies, Flour was designed to be dropped in to any web project with minimum effort. Using Flour will usually start by creating a `view`. A most simple `view` will look like this.

<pre>
	flour.view.add('hello_world', function() {
	{
		this.templateHTML = `
			<p>Hello world</p>
		`;
	});
</pre>


Views in Flour have various life-cycle hooks and properties. State for your view lives in the `state` property. Using the `init` life-cycle method which is called once when the view is created is a good place to set default state values. 

<pre>
	flour.view.add('hello_world_2', function() {

		this.init = () => {
			this.state.set('name', 'Gerwin');
		};


		this.templateHTML = `
			<p>Hello {{name}}</p>
		`;

	});
</pre>


Your view's state is used to populate values in the view's `templateHTML` property. Flour's template engine uses bindings that are special attributes added to elements in the HTML. Flour's bindings are all prefixed with `f-` so it's easy to distinguish them from standard HTML attributes.

<pre>
	flour.view.add('hello_world_3', function() {

		this.init = () => {
			this.state.set('name', 'Gerwin');
		};


		this.templateHTML = `
			<div>
				<input type="text" f-value="name" />
			</div>
			<p>Hello <span f-text="name"></span></p>
		`;

	});
</pre>


Bindings can do all kinds of things and Flour comes with several that should fullfil most requirements. Here we'll use the `f-on` binding to add a click event to our button.

<pre>
	flour.view.add('button_counter', function() {

		this.init = () => {
			this.state.set('count', 0);
		};


		this.handleButtonClick = () => {
			this.state.set('count', this.state.get('count') + 1);
		};


		this.templateHTML = `
			<div>
				<button f-on="click handleButtonClick">Count: <span f-text="count"></span></button>
			</div>
		`;

	});
</pre>


As well as bindings, Flour also has a block syntax for certain use cases. The `list` block is the default way to display an array of items.

<pre>
	flour.view.add('list', function() {

		this.init = () => {
			this.state.set('dwarves', 
			[
				{
					id: 0,
					name: 'Thorin'
				},
				{
					id: 1,
					name: 'Fili'
				},
				{
					id: 2,
					name: 'Kili'
				}
			]);
		};


		this.templateHTML = `
			<div>
				{{#list dwarves}}
					<div>{{name}}</div>
				{{/list}}
			</div>
		`;

	});
</pre>


As applications become more complex, moving functionality into children views improves maintainability.

<pre>
	flour.view.add('parent_view', function() {

		this.init = () => {
			this.embedView('child_view', this.getView('child_view'));
		};


		this.templateHTML = `
			<div>
				<div f-view="child_view"></div>
			</div>
		`;

	});


	flour.view.add('child_view', function() {

		this.templateHTML = `
			<div>
				<p>Hello from child view.</p>
			</div>
		`;

	});
</pre>


Flour wraps HTML's custom elements api to allow views to be made into "components". Custom elements are extremely powerful and well suited for building simple re-usable pieces of UI. Flour wrapped custom elements can be used outside of flour views as well.

<pre>
	flour.view.add('card', function() {

		this.templateHTML = `
			<style>
				.card{
					padding: 16px;
					border-radius: 8px;
					background-color: #fff;
					box-shadow: 0 4px 8px rgba(0,0,0,.05);
				}
			</style>
			<div class="card">
				<slot></slot>
			</div>
		`;

	});

	flour.customElement.add('white-card', {
		view: 'card',
		shadow: true
	});
</pre>